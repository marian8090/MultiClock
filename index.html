<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MultiClock</title>
    <script src="https://pixijs.download/release/pixi.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: Arial, sans-serif;
        }

        #clock-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #clock-number {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #00ff00;
            font-size: 18px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            opacity: 0.8;
        }

        #help-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00ff00;
            font-size: 14px;
            z-index: 2000;
            font-family: 'Courier New', Courier, monospace;
            opacity: 0.9;
            white-space: pre;
            line-height: 1.4;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 4px;
            display: none;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>

    <div id="clock-container"></div>
    <div id="clock-number">1</div>

    <div id="help-overlay">MultiClock Controls
1: Analog Clock
2: Digital Clock
3: 7-Segment LED
↑↓: Navigate parameters
←→: Change values
F: Toggle fullscreen
H: Show this help</div>

    <script type="module">
        import { AnalogClock } from './clocks/1_analog-clock.js';
        import { DigitalClock } from './clocks/2_digital-clock.js';
        import { SevenSegmentLedClock } from './clocks/3_7segment-led.js';
        import { SettingsSync } from './js/settings-sync.js';

        class MultiClock {
            constructor() {
                this.clocks = [
                    { name: 'Analog', class: AnalogClock },
                    { name: 'Digital', class: DigitalClock },
                    { name: '7-Segment LED', class: SevenSegmentLedClock }
                ];
                this.currentClockIndex = 0;
                this.currentClockInstance = null;
                this.container = document.getElementById('clock-container');
                this.clockNumberDisplay = document.getElementById('clock-number');
                this.helpOverlay = document.getElementById('help-overlay');
                this.helpTimeout = null;
                this.isReceivingSync = false; // Flag to prevent sync loops

                // Initialize synchronization
                this.sync = new SettingsSync();
                this.setupSyncCallbacks();
                this.sync.connect();

                this.setupEventListeners();
                this.loadClock(0);
            }

            setupSyncCallbacks() {
                // Handle incoming clock changes from other clients
                this.sync.onClockChange((clockIndex) => {
                    if (!this.isReceivingSync && clockIndex !== this.currentClockIndex) {
                        this.isReceivingSync = true;
                        this.switchToClock(clockIndex);
                        this.isReceivingSync = false;
                    }
                });

                // Handle incoming parameter changes from other clients
                this.sync.onParameterChange((data) => {
                    if (!this.isReceivingSync &&
                        data.clockIndex === this.currentClockIndex &&
                        this.currentClockInstance) {
                        this.isReceivingSync = true;

                        // Apply the parameter change to current clock
                        this.applyParameterChange(data.parameter, data.value);

                        this.isReceivingSync = false;
                    }
                });

                // Handle full state synchronization
                this.sync.onStateSync((state) => {
                    if (!this.isReceivingSync) {
                        this.isReceivingSync = true;

                        // Switch to the synchronized clock if different
                        if (state.clockIndex !== this.currentClockIndex) {
                            this.switchToClock(state.clockIndex);
                        }

                        // Apply saved settings for current clock
                        if (this.currentClockInstance && state.clockSettings) {
                            const clockKey = `clock_${this.currentClockIndex}`;
                            const settings = state.clockSettings[clockKey];
                            if (settings) {
                                this.sync.applyClockParameters(this.currentClockInstance, settings);
                            }
                        }

                        this.isReceivingSync = false;
                    }
                });

                // Handle connection status changes
                this.sync.onConnectionChange((connected) => {
                    console.log(connected ? 'Sync connected' : 'Sync disconnected');
                });
            }

            applyParameterChange(parameter, value) {
                if (!this.currentClockInstance) return;

                switch (parameter) {
                    case 'SIZE':
                        if (this.currentClockInstance.currentSizeMultiplier !== undefined) {
                            this.currentClockInstance.currentSizeMultiplier = value;
                            if (this.currentClockInstance.updateSize) {
                                this.currentClockInstance.updateSize();
                            }
                        }
                        break;
                    case 'COLOR':
                        if (this.currentClockInstance.currentColor !== undefined) {
                            this.currentClockInstance.currentColor = value;
                            if (this.currentClockInstance.updateColor) {
                                this.currentClockInstance.updateColor();
                            }
                        }
                        break;
                    case 'FONT':
                        if (this.currentClockInstance.currentFont !== undefined) {
                            this.currentClockInstance.currentFont = value;
                            if (this.currentClockInstance.updateFont) {
                                this.currentClockInstance.updateFont();
                            }
                        }
                        break;
                    case 'FONTSIZE':
                        if (this.currentClockInstance.currentFontSizeMultiplier !== undefined) {
                            this.currentClockInstance.currentFontSizeMultiplier = value;
                            if (this.currentClockInstance.updateFontSize) {
                                this.currentClockInstance.updateFontSize();
                            }
                        }
                        break;
                    case 'FONT COLOUR':
                        if (this.currentClockInstance.currentColor !== undefined) {
                            this.currentClockInstance.currentColor = value;
                            if (this.currentClockInstance.updateColor) {
                                this.currentClockInstance.updateColor();
                            }
                        }
                        break;
                    case 'RENDERER':
                        if (this.currentClockInstance.currentRenderMode !== undefined) {
                            this.currentClockInstance.currentRenderMode = value;
                            if (this.currentClockInstance.updateRenderMode) {
                                this.currentClockInstance.updateRenderMode();
                            }
                        }
                        break;
                }
            }

            setupEventListeners() {
                document.addEventListener('keydown', (event) => {
                    switch(event.key) {
                        case '1':
                        case '2':
                        case '3':
                            const clockIndex = parseInt(event.key) - 1;
                            if (clockIndex >= 0 && clockIndex < this.clocks.length) {
                                this.switchToClock(clockIndex);
                            }
                            this.hideHelp();
                            break;

                        case 'ArrowUp':
                            if (this.currentClockInstance && this.currentClockInstance.navigateParameterUp) {
                                this.currentClockInstance.navigateParameterUp();
                            }
                            this.hideHelp();
                            break;

                        case 'ArrowDown':
                            if (this.currentClockInstance && this.currentClockInstance.navigateParameterDown) {
                                this.currentClockInstance.navigateParameterDown();
                            }
                            this.hideHelp();
                            break;

                        case 'ArrowLeft':
                            if (this.currentClockInstance && this.currentClockInstance.changeParameterLeft) {
                                this.currentClockInstance.changeParameterLeft();
                            }
                            this.hideHelp();
                            break;

                        case 'ArrowRight':
                            if (this.currentClockInstance && this.currentClockInstance.changeParameterRight) {
                                this.currentClockInstance.changeParameterRight();
                            }
                            this.hideHelp();
                            break;

                        case 'f':
                        case 'F':
                            this.toggleFullscreen();
                            this.hideHelp();
                            break;

                        case 'h':
                        case 'H':
                            this.showHelp();
                            break;
                    }
                });

                // Auto-enter fullscreen on load
                document.addEventListener('DOMContentLoaded', () => {
                    setTimeout(() => this.enterFullscreen(), 100);
                });
            }

            async loadClock(index) {
                if (this.currentClockInstance) {
                    this.currentClockInstance.destroy();
                    this.clearContainer();
                }

                this.currentClockIndex = index;
                const ClockClass = this.clocks[index].class;
                this.currentClockInstance = new ClockClass();

                try {
                    await this.currentClockInstance.init(this.container);
                    this.updateClockNumber();

                    // Set up sync integration for the new clock instance
                    this.setupClockSync(this.currentClockInstance);
                } catch (error) {
                    console.error('Failed to load clock:', error);
                }
            }

            setupClockSync(clockInstance) {
                if (!clockInstance || !this.sync) return;

                // Store reference to MultiClock instance for sync callbacks
                clockInstance.multiClock = this;

                // Override parameter change methods to broadcast changes
                const originalChangeParameterLeft = clockInstance.changeParameterLeft?.bind(clockInstance);
                const originalChangeParameterRight = clockInstance.changeParameterRight?.bind(clockInstance);

                if (originalChangeParameterLeft) {
                    clockInstance.changeParameterLeft = () => {
                        originalChangeParameterLeft();
                        this.broadcastCurrentParameter();
                    };
                }

                if (originalChangeParameterRight) {
                    clockInstance.changeParameterRight = () => {
                        originalChangeParameterRight();
                        this.broadcastCurrentParameter();
                    };
                }
            }

            broadcastCurrentParameter() {
                if (!this.currentClockInstance || !this.sync || this.isReceivingSync) return;

                const parameter = this.currentClockInstance.parameters?.[this.currentClockInstance.currentParameterIndex];
                if (!parameter) return;

                let value;
                switch (parameter) {
                    case 'SIZE':
                        value = this.currentClockInstance.currentSizeMultiplier;
                        break;
                    case 'COLOR':
                        value = this.currentClockInstance.currentColor;
                        break;
                    case 'FONT':
                        value = this.currentClockInstance.currentFont;
                        break;
                    case 'FONTSIZE':
                        value = this.currentClockInstance.currentFontSizeMultiplier;
                        break;
                    case 'FONT COLOUR':
                        value = this.currentClockInstance.currentColor;
                        break;
                    case 'RENDERER':
                        value = this.currentClockInstance.currentRenderMode;
                        break;
                    default:
                        return;
                }

                if (value !== undefined) {
                    this.sync.broadcastParameterChange(this.currentClockIndex, parameter, value);
                }
            }

            switchToClock(index) {
                if (index !== this.currentClockIndex) {
                    this.loadClock(index);

                    // Broadcast clock change to other clients (only if not receiving sync)
                    if (!this.isReceivingSync && this.sync) {
                        this.sync.broadcastClockChange(index);
                    }
                }
            }

            updateClockNumber() {
                this.clockNumberDisplay.textContent = (this.currentClockIndex + 1).toString();
            }


            clearContainer() {
                while (this.container.firstChild) {
                    this.container.removeChild(this.container.firstChild);
                }
            }

            showHelp() {
                this.helpOverlay.style.display = 'block';

                // Clear existing timeout
                if (this.helpTimeout) {
                    clearTimeout(this.helpTimeout);
                }

                // Auto-hide after 3 seconds
                this.helpTimeout = setTimeout(() => {
                    this.hideHelp();
                }, 3000);
            }

            hideHelp() {
                this.helpOverlay.style.display = 'none';
                if (this.helpTimeout) {
                    clearTimeout(this.helpTimeout);
                    this.helpTimeout = null;
                }
            }


            enterFullscreen() {
                const element = document.documentElement;
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                } else if (element.mozRequestFullScreen) {
                    element.mozRequestFullScreen();
                } else if (element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen();
                } else if (element.msRequestFullscreen) {
                    element.msRequestFullscreen();
                }
            }

            exitFullscreen() {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }

            toggleFullscreen() {
                if (!document.fullscreenElement && !document.mozFullScreenElement &&
                    !document.webkitFullscreenElement && !document.msFullscreenElement) {
                    this.enterFullscreen();
                } else {
                    this.exitFullscreen();
                }
            }
        }

        // Initialize MultiClock when the page loads
        window.addEventListener('load', () => {
            new MultiClock();
        });
    </script>
</body>
</html>